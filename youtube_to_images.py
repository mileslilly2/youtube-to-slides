# -*- coding: utf-8 -*-
"""youtube_to_images.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FcZmV4hViEGd2lvg3sw1Drty3s5j1V2I
"""

!pip install opencv-python
!pip install moviepy
!pip install imageio[ffmpeg]
!pip install pydub
!pip install pytube=12.0.0
!pip install python-pptx

!pip install --upgrade pytube



from pytube import YouTube
import cv2
import os
import math
from pptx import Presentation
from pptx.util import Inches
import os

"""
### Overall Software Documentation

This software suite comprises three distinct functions, each addressing a specific aspect of media processing and presentation. The first function, `download_youtube_as_mp4`, allows users to download YouTube videos in MP4 format at a specified resolution, utilizing the `pytube` library. The second function, `extract_frames_cv2`, is designed for extracting frames from a given video at specified time intervals, leveraging the `cv2` (OpenCV) library for frame processing. Finally, the `images_to_ppt` function enables the creation of a PowerPoint presentation from a collection of images stored in a specified directory, using the `python-pptx` library. Together, these functions provide a comprehensive toolkit for video downloading, frame extraction, and presentation creation, useful in various multimedia and content creation workflows."""

### Documentation for Each Function

#### 1. `download_youtube_as_mp4(video_url, resolution)`
   #- **video_url** *(string)*: The URL of the YouTube video to be downloaded.
   #- **resolution** *(string)*: The desired resolution of the downloaded video (e.g., '720p', '1080p').

#### 2. `extract_frames_cv2(video_path, seconds)`
   #- **video_path** *(string)*: The file path of the video from which frames are to be extracted.
   #- **seconds** *(int/float)*: Interval in seconds at which frames will be extracted.

#### 3. `images_to_ppt(directory, ppt_file)`
   #- **directory** *(string)*: The path to the directory containing the images to be included in the PowerPoint presentation.
   #- **ppt_file** *(string)*: The name or path for the output PowerPoint file.

def download_youtube_as_mp4(video_url, resolution):


    # Create a YouTube object and get the video stream
    youtube = YouTube(video_url)
    video_stream = youtube.streams.filter(progressive=True, file_extension='mp4', res=resolution).first()

    if video_stream is None:
        print(f"No video found with resolution {resolution}")
        return None

    # Function to track the progress of the download
    def progress_function(stream, chunk, bytes_remaining):
        current = (stream.filesize - bytes_remaining)
        percent = (current / stream.filesize) * 100
        print(f"Downloaded {current} of {stream.filesize} bytes ({percent:.2f}%)")

    # Register the progress function
    youtube.register_on_progress_callback(progress_function)

    # Download the video stream as an MP4 file
    mp4_file_path = video_stream.download()

    return mp4_file_path

def images_to_ppt(directory, ppt_file):
    # Append '.pptx' to the file name if it's not already there
    if not ppt_file.endswith('.pptx'):
        ppt_file += '.pptx'

    prs = Presentation()  # Create a new presentation

    # Get a list of all the image files in the directory
    images = [f for f in os.listdir(directory) if f.endswith(('.png', '.jpg', '.jpeg', '.gif'))]

     # Sort the list of image filenames
    images = sorted(images)
    # Add a slide with an image for each image file
    for image_file in images:
        slide_layout = prs.slide_layouts[5]  # Use the blank slide layout (layout 5)
        slide = prs.slides.add_slide(slide_layout)

        width = Inches(10)  # Define width and height of the image on the slide
        height = Inches(7.5)
        left = 0
        top = 0

        # Add the image
        slide.shapes.add_picture(os.path.join(directory, image_file), left, top, width, height)

    # Save the presentation
    prs.save(ppt_file)

def extract_frames_cv2(video_path, seconds):
    vidcap = cv2.VideoCapture(video_path)
    fps = vidcap.get(cv2.CAP_PROP_FPS)  # Gets the frames per second
    multiplier = round(fps * seconds)

    # Debug lines
    print(f"FPS: {fps}")
    print(f"Multiplier: {multiplier}")

    directory_name = os.path.basename(video_path)[:30]
    if not os.path.exists(directory_name):
        os.makedirs(directory_name)

    frame_number = 0
    while vidcap.isOpened():

        frame_id = int(round(vidcap.get(1)))  # Current frame number
        ret, frame = vidcap.read()

        # Debug line
        #print(f"Frame ID: {frame_id}, Return value: {ret}")
        #print(ret)
        if not ret:
            break
        #print(frame)
        if frame_id % multiplier == 0:
            frame_number += 1
            print('Has reaches the multiplier')
            # Pad frame_number with leading zeros
            padded_frame_number = str(frame_number).zfill(5)  # Pad with 5 zeros for example
            cv2.imwrite(os.path.join(directory_name, f"frame{padded_frame_number}.jpg"), frame)

    vidcap.release()
    return directory_name

# Example usage
extract_frames_cv2("your_video_file_here.mp4", 1)

import os
import pickle
from PIL import Image

def pickle_images(directory):
    images = []  # Create a list to store the images.

    # Sort the list of image filenames
    sorted_image_names = sorted(os.listdir(directory))

    for image_name in sorted_image_names:
        image_path = os.path.join(directory, image_name)  # Construct the full image path

        try:
            with Image.open(image_path) as image:  # Open the image
                images.append(image.copy())  # Append a copy of the image to the list
        except IOError:
            print(f"Unable to open {image_name}")  # Handle the exception for an unreadable file

    # Pickle the list of images.
    with open('images.pkl', 'wb') as f:
        pickle.dump(images, f)

!jupyter nbconvert --to script youtube_to_images.ipynb





video_url = 'https://www.youtube.com/watch?v=PaCmpygFfXo&t=2657s&ab_channel=AndrejKarpathy'

downloaded_video = download_youtube_as_mp4(video_url, '720p')

directory_name = extract_frames_cv2(downloaded_video, 30)

directory_name

pickle_images(directory_name)

images_to_ppt(directory_name, 'makemoreANDmore')

# Commented out IPython magic to ensure Python compatibility.
# %%capture
#



'''from moviepy.editor import VideoFileClip

def extract_frames_VideoFileClip(video_path, seconds):
    clip = VideoFileClip(video_path)
    fps = clip.fps  # Gets the frames per second

    for i in range(0, int(clip.duration), seconds):
        frame = clip.get_frame(i)
        frame.save_frame(f"frame{i}.jpg", t=i)

extract_frames('path_to_your_video.mp4', N)  # Replace N with the number of seconds
'''

'''import imageio

reader = imageio.get_reader_imageio('path_to_your_video.mp4')
fps = reader.get_meta_data()['fps']  # Gets the frames per second

for i, im in enumerate(reader):
    if i % (fps * N) == 0:  # Replace N with the number of seconds
        imageio.imwrite(f'frame{i}.jpg', im)'''

print(var)



images_to_ppt('/content/Daniel Chen - Install Python Q' , 'Building an Audio Transcription App3.pptx')